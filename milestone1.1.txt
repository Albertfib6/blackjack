Hemos solucionado los errores que nos dijiste:

-sys_exit tiene que liberar todos los recursos de TODOS los threads del
proceso.

    sys_exit modficado en sys.c

-sys_threadcreate: no se modifica el contexto hardware para que salte,
cuando vuelva a modo usuario, a la funcion del thread, sino a un wrapper
que teneis que implementar en libc.c que tiene que ejecutar la funcion
del thread y luego threadexit (como se explico en clase)

    Hemos implementado el wrapper (thread_wrapper) en user-utils.S
    Cuando vuelve a modo usuario pasa a ejecutar ese wrapper

-no veo donde habeis implementado que errno sea por thread (TLS)
    
    Nuevo campo en el task struct de cada thread, se puede acceder con una nueva syscall get_errno

-access_ok tiene que tener en cuenta tambien la pila de usuario del
thread actual. 
    
    access_ok modificada en utils.c 
