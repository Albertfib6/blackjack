#include <libc.h>

/* Función para probar la pila profunda */
void funcion_thread_pesado(void *parametro) {
    int id = (int)parametro;
    
    write(1, "Thread iniciado. Intentando romper la pila...\n", 46);

    /* PRUEBA DE FUEGO: Crecimiento de Pila
       El enunciado dice que la pila inicial es 1 página (4096 bytes).
       Creamos un array de 5000 bytes. Al escribir en el final, 
       nos salimos de la página inicial.
       
       - Si tu page_fault_routine funciona: El sistema pausa, asigna memoria y sigue.
       - Si falla: Saldrá un error de sistema o el ordenador se reiniciará.
    */
    char array_gigante[6000]; 
    
    // Escribimos lejos para forzar el Page Fault
    array_gigante[0] = 'A';
    array_gigante[5000] = 'Z'; 

    if (array_gigante[0] == 'A' && array_gigante[5000] == 'Z') {
        write(1, "EXITO: La pila ha crecido dinamicamente!\n", 41);
    } else {
        write(1, "ERROR: Memoria corrupta\n", 24);
    }

    /* Probamos que ThreadExit funcione */
    ThreadExit();
}

int __attribute__ ((__section__(".text.main")))
  main(void)
{
    /* Test 1: Creación Básica */
    write(1, "Iniciando Test Milestone 1...\n", 30);
    
    int pid_hilo = ThreadCreate(funcion_thread_pesado, (void*)1);

    if (pid_hilo < 0) {
        write(1, "ERROR: Fallo al crear hilo\n", 27);
    } else {
        write(1, "Hilo creado correctamente. Esperando...\n", 40);
    }

    /* Hacemos un bucle para esperar y no terminar el proceso padre inmediatamente.
       En un caso real usarías algún mecanismo de sincronización, 
       pero un while largo sirve para ver el resultado en pantalla.
    */
    long i;
    for (i = 0; i < 100000000; i++); 

    write(1, "Test finalizado.\n", 17);

    while(1);
}


/* En sys.c - Sustituye sys_ThreadCreate por esto */

#define FORCE_STACK_PAGE 500

int sys_ThreadCreate(void (*function)(void* arg), void* parameter) {
  
  /* DEBUG 1: Inicio */
  printk("Kernel: ThreadCreate iniciado.\n");

  struct task_struct *uchild_struct;
  struct list_head *lhcurrent = NULL;
  union task_union *uchild;
  
  if (list_empty(&freequeue)) {
      printk("Kernel: Error - Freequeue vacia (Falta init_sched en main?)\n");
      return -ENOMEM;
  }

  lhcurrent = list_first(&freequeue);
  list_del(lhcurrent);
  
  uchild = (union task_union*)list_head_to_task_struct(lhcurrent);
  uchild_struct = &uchild->task;
  
  copy_data(current(), uchild, sizeof(union task_union));
  
  uchild_struct->TID = ++next_free_id;
  uchild_struct->PID = current()->PID; 
  uchild_struct->state = ST_READY;

  /* --- ZONA DE LA VERDAD --- */
  
  /* FUERZA BRUTA: Usamos la pagina 500 si o si. */
  int stack_ini = FORCE_STACK_PAGE;
  int pages_needed = 20;

  uchild_struct->PAG_INICI = stack_ini; 
  uchild_struct->STACK_PAGES = pages_needed; 

  /* Asignar memoria física para la CIMA de la pila */
  int logical_page_top = stack_ini + pages_needed - 1;
  
  /* Aseguramos que la pagina este limpia antes de asignar */
  page_table_entry *current_PT = get_PT(current());
  del_ss_pag(current_PT, logical_page_top); 

  int new_ph_pag = alloc_frame();
  
  if (new_ph_pag == -1) {
      printk("Kernel: Error - No hay memoria fisica (alloc_frame fallo)\n");
      list_add_tail(lhcurrent, &freequeue);
      return -EAGAIN;
  }
  
  set_ss_pag(current_PT, logical_page_top, new_ph_pag);

  /* CRITICO: Limpiar TLB para que la CPU vea la nueva memoria */
  set_cr3(get_DIR(current())); 

  /* DEBUG 2: Memoria asignada */
  printk("Kernel: Pagina asignada y TLB flush hecho.\n");

  /* Preparar Pila de Usuario */
  unsigned int user_stack_base = (logical_page_top + 1) << 12;
  unsigned int *stack_ptr = (unsigned int *)user_stack_base;
  
  /* PRUEBA DE ESCRITURA: Si esto falla, crashea el sistema */
  stack_ptr -= 1; 
  *stack_ptr = (unsigned int)parameter; 
  
  stack_ptr -= 1; 
  *stack_ptr = 0; // Return address 0 para provocar fallo controlado si retorna

  /* DEBUG 3: Pila de usuario escrita */
  printk("Kernel: Pila de usuario escrita OK.\n");

  /* Preparar Kernel Stack */
  uchild->stack[KERNEL_STACK_SIZE - 2] = (unsigned long)stack_ptr; 
  uchild->stack[KERNEL_STACK_SIZE - 5] = (unsigned long)function;  

  unsigned long *ksp = &uchild->stack[KERNEL_STACK_SIZE - 5];
  ksp -= 10; 
  ksp -= 1; 
  *ksp = 0; 
  ksp -= 1; 
  *ksp = (unsigned long) ret_from_fork; 

  uchild->task.register_esp = (unsigned long) ksp;

  init_stats(&uchild_struct->p_stats);
  list_add_tail(&uchild_struct->list, &readyqueue);

  printk("Kernel: Thread encolado. EXITO.\n");
  return uchild_struct->TID;
}
