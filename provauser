#include <libc.h>

/* Función para probar la pila profunda */
void funcion_thread_pesado(void *parametro) {
    int id = (int)parametro;
    
    write(1, "Thread iniciado. Intentando romper la pila...\n", 46);

    /* PRUEBA DE FUEGO: Crecimiento de Pila
       El enunciado dice que la pila inicial es 1 página (4096 bytes).
       Creamos un array de 5000 bytes. Al escribir en el final, 
       nos salimos de la página inicial.
       
       - Si tu page_fault_routine funciona: El sistema pausa, asigna memoria y sigue.
       - Si falla: Saldrá un error de sistema o el ordenador se reiniciará.
    */
    char array_gigante[6000]; 
    
    // Escribimos lejos para forzar el Page Fault
    array_gigante[0] = 'A';
    array_gigante[5000] = 'Z'; 

    if (array_gigante[0] == 'A' && array_gigante[5000] == 'Z') {
        write(1, "EXITO: La pila ha crecido dinamicamente!\n", 41);
    } else {
        write(1, "ERROR: Memoria corrupta\n", 24);
    }

    /* Probamos que ThreadExit funcione */
    ThreadExit();
}

int __attribute__ ((__section__(".text.main")))
  main(void)
{
    /* Test 1: Creación Básica */
    write(1, "Iniciando Test Milestone 1...\n", 30);
    
    int pid_hilo = ThreadCreate(funcion_thread_pesado, (void*)1);

    if (pid_hilo < 0) {
        write(1, "ERROR: Fallo al crear hilo\n", 27);
    } else {
        write(1, "Hilo creado correctamente. Esperando...\n", 40);
    }

    /* Hacemos un bucle para esperar y no terminar el proceso padre inmediatamente.
       En un caso real usarías algún mecanismo de sincronización, 
       pero un while largo sirve para ver el resultado en pantalla.
    */
    long i;
    for (i = 0; i < 100000000; i++); 

    write(1, "Test finalizado.\n", 17);

    while(1);
}


/* En sys.c - Versión FINAL para entregar */

int sys_ThreadCreate(void (*function)(void* arg), void* parameter) {
  struct task_struct *uchild_struct;
  struct list_head *lhcurrent = NULL;
  union task_union *uchild;
  
  if (list_empty(&freequeue)) return -ENOMEM;

  lhcurrent = list_first(&freequeue);
  list_del(lhcurrent);
  
  uchild = (union task_union*)list_head_to_task_struct(lhcurrent);
  uchild_struct = &uchild->task;
  
  copy_data(current(), uchild, sizeof(union task_union));
  
  uchild_struct->TID = ++next_free_id;
  uchild_struct->PID = current()->PID; 
  uchild_struct->state = ST_READY;

  /* 3. Buscar hueco REAL (Rango seguro 300-900) */
  page_table_entry *current_PT = get_PT(current());
  int stack_ini = -1;
  int pages_needed = MAX_USER_STACK_PAGES; // Asegurate que es 20 o similar

  for (int start = 300; start < 900; start++) {
      int free = 1;
      for (int offset = 0; offset < pages_needed; offset++) {
          if (get_frame(current_PT, start + offset) != -1) {
              free = 0;
              start += offset; 
              break;
          }
      }
      if (free) {
          stack_ini = start;
          break;
      }
  }

  if (stack_ini == -1) {
      list_add_tail(lhcurrent, &freequeue);
      return -ENOMEM;
  }

  uchild_struct->PAG_INICI = stack_ini; 
  uchild_struct->STACK_PAGES = pages_needed; 

  /* 4. Asignar memoria física inicial */
  int logical_page_top = stack_ini + pages_needed - 1;
  int new_ph_pag = alloc_frame();
  
  if (new_ph_pag == -1) {
      list_add_tail(lhcurrent, &freequeue);
      return -EAGAIN;
  }
  
  set_ss_pag(current_PT, logical_page_top, new_ph_pag);
  set_cr3(get_DIR(current())); /* FLUSH TLB IMPRESCINDIBLE */

  /* 5. Preparar Pila de Usuario */
  unsigned int user_stack_base = (logical_page_top + 1) << 12;
  unsigned int *stack_ptr = (unsigned int *)user_stack_base;
  
  stack_ptr -= 1; 
  *stack_ptr = (unsigned int)parameter; 
  
  stack_ptr -= 1; 
  *stack_ptr = 0; // Return address fake

  /* 6. Preparar Kernel Stack */
  uchild->stack[KERNEL_STACK_SIZE - 2] = (unsigned long)stack_ptr; 
  uchild->stack[KERNEL_STACK_SIZE - 5] = (unsigned long)function;  

  unsigned long *ksp = &uchild->stack[KERNEL_STACK_SIZE - 5];
  ksp -= 10; 
  ksp -= 1; *ksp = 0; 
  ksp -= 1; *ksp = (unsigned long) ret_from_fork; 

  uchild->task.register_esp = (unsigned long) ksp;

  init_stats(&uchild_struct->p_stats);
  list_add_tail(&uchild_struct->list, &readyqueue);

  return uchild_struct->TID;
}
